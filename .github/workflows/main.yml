name: Auto Tag (Shell Script Puro)

on:
  push:
    branches:
      - main # Altere para 'master' se for o caso do seu repositório

jobs:
  generate-tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Permissão necessária para criar e enviar a tag

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Essencial: Baixa todo o histórico para o git log funcionar corretamente

      - name: Calcular e Criar Tag
        shell: bash
        run: |
          # --- CONFIGURAÇÃO DO GIT ---
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # --- PASSO 1: OBTER A ÚLTIMA TAG ---
          # Pega a última tag. Se falhar (ex: repo sem tags), usa v0.0.0
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Tag atual encontrada: $LAST_TAG"

          # Remove o 'v' e separa os números
          VERSION_NO_PREFIX=${LAST_TAG#v}
          IFS='.' read -r -a PARTS <<< "$VERSION_NO_PREFIX"
          MAJOR=${PARTS[0]:-0}
          MINOR=${PARTS[1]:-0}
          PATCH=${PARTS[2]:-0}

          # --- PASSO 2: OBTER COMMITS DESDE A ÚLTIMA TAG ---
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%s")
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s")
          fi

          # --- PASSO 3: ANALISAR PRECEDÊNCIA DOS COMMITS ---
          MAIOR_PRECEDENCIA=0

          echo "Analisando commits..."
          while IFS= read -r msg; do
            # Ignora linhas vazias
            if [ -z "$msg" ]; then continue; fi
            
            # Extrai o prefixo (tudo antes do ':')
            PREFIXO=$(echo "$msg" | cut -d':' -f1)
            PRECEDENCIA_ATUAL = 0

            # Regras de precedência
            if [[ "$msg" == *"BREAKING CHANGE"* ]] || [[ "$PREFIXO" == *"!"* ]]; then
              PRECEDENCIA_ATUAL=3 # MAJOR
              
            elif [[ "$PREFIXO" == feat* ]]; then
              PRECEDENCIA_ATUAL=2 # MINOR
              
            elif [[ -n "$PREFIXO" && "$PREFIXO" != "$msg" ]]; then
              PRECEDENCIA_ATUAL=1 # PATCH
            else
              PRECEDENCIA_ATUAL = 1
            fi

            # Atualiza a maior precedência encontrada
            if [[ $PRECEDENCIA_ATUAL -gt $MAIOR_PRECEDENCIA ]]; then
              MAIOR_PRECEDENCIA=$PRECEDENCIA_ATUAL
            fi
            
            echo " - Commit: '$msg' | Prefixo: '$PREFIXO' | Peso: $PRECEDENCIA_ATUAL"
          done <<< "$COMMITS"

          echo "Peso máximo encontrado no histórico: $MAIOR_PRECEDENCIA"

          # calcula nova versão de acordo com a variavel MAIOR_PRECEDENCIA
          if [[ $MAIOR_PRECEDENCIA -eq 3 ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR = 0
            PATCH = 0
            echo "Ação: Incrementando MAJOR."
          elif [[ $MAIOR_PRECEDENCIA -eq 2 ]]; then
            MINOR = $((MINOR + 1))
            PATCH = 0
            echo "Ação: Incrementando MINOR."
          elif [[ $MAIOR_PRECEDENCIA -eq 1 ]]; then
            PATCH = $((PATCH + 1))
            echo "Ação: Incrementando PATCH."
          else
            PATCH = $((PATCH + 1))
            echo "Nenhum commit relevante incrementa o PATCH"
          fi

          NEW_TAG="v$MAJOR.$MINOR.$PATCH"
          echo "Nova tag calculada: $NEW_TAG"

          # cria e envia a tag
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "Aviso: A tag $NEW_TAG já existe no repositório. Abortando criação."
            exit 0
          else
            git tag "$NEW_TAG"
            git push origin "$NEW_TAG"
            echo "Sucesso! Tag $NEW_TAG criada e enviada para o repositório."
          fi
